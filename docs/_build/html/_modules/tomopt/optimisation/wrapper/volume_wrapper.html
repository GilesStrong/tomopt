


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tomopt.optimisation.wrapper.volume_wrapper &mdash; TomOpt  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

  <!-- Preload the theme fonts -->

<link rel="preload" href="../../../../_static/fonts/FreightSans/freight-sans-book.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/FreightSans/freight-sans-medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/IBMPlexMono/IBMPlexMono-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/FreightSans/freight-sans-bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/FreightSans/freight-sans-medium-italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/IBMPlexMono/IBMPlexMono-SemiBold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<!-- Preload the katex fonts -->

<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Math-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size1-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size4-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size2-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size3-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Caligraphic-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://tomopt.readthedocs.io/en/stable" aria-label="TomOpt"></a>

      <div class="main-menu">
        <ul>
          <!-- <li>
            <a href="">Get Started</a>
          </li> -->

          <!-- <li>
            <a href="">Features</a>
          </li> -->

          <!-- <li>
            <a href="">Ecosystem</a>
          </li> -->

          <!-- <li>
            <a href="">Blog</a>
          </li> -->

          <li>
            <a href="https://github.com/GilesStrong/mode_muon_tomography#examples">Tutorials</a>
          </li>

          <li>
            <a href="https://tomopt.readthedocs.io/en/stable">Docs</a>
          </li>

          <!-- <li>
            <a href="">Resources</a>
          </li> -->

          <li>
            <a href="https://github.com/GilesStrong/mode_muon_tomography">Github</a>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>

  </div>
</div>


<body class="pytorch-body">

   

    

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">
            

            
              
              
            

            


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

            
          </div>

          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html#testing">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html#external-repos">External repos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html#authors">Authors</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tomopt.html">tomopt package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tomopt.muon.html">tomopt.muon package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tomopt.volume.html">tomopt.volume package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tomopt.inference.html">tomopt.inference package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tomopt.optimisation.html">tomopt.optimisation package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tomopt.plotting.html">tomopt.plotting package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tomopt.benchmarks.html">tomopt.benchmarks package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="../../../../index.html">
          
            Docs
          
        </a> &gt;
      </li>

        
          <li><a href="../../../index.html">Module code</a> &gt;</li>
        
      <li>tomopt.optimisation.wrapper.volume_wrapper</li>
    
    
      <li class="pytorch-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">

        
          
          <div class="rst-content">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
              
  <h1>Source code for tomopt.optimisation.wrapper.volume_wrapper</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">fastcore.all</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">fastprogress</span> <span class="kn">import</span> <span class="n">master_bar</span><span class="p">,</span> <span class="n">progress_bar</span>
<span class="kn">from</span> <span class="nn">fastprogress.fastprogress</span> <span class="kn">import</span> <span class="n">ConsoleProgressBar</span><span class="p">,</span> <span class="n">NBProgressBar</span><span class="p">,</span> <span class="n">ProgressBar</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="nn">torch.optim.optimizer</span> <span class="kn">import</span> <span class="n">Optimizer</span>

<span class="kn">from</span> <span class="nn">...core</span> <span class="kn">import</span> <span class="n">DEVICE</span><span class="p">,</span> <span class="n">PartialOpt</span>
<span class="kn">from</span> <span class="nn">...inference</span> <span class="kn">import</span> <span class="n">AbsVolumeInferrer</span><span class="p">,</span> <span class="n">PanelX0Inferrer</span><span class="p">,</span> <span class="n">ScatterBatch</span>
<span class="kn">from</span> <span class="nn">...muon</span> <span class="kn">import</span> <span class="n">AbsMuonGenerator</span><span class="p">,</span> <span class="n">MuonBatch</span><span class="p">,</span> <span class="n">MuonGenerator2016</span>
<span class="kn">from</span> <span class="nn">...optimisation.loss.loss</span> <span class="kn">import</span> <span class="n">AbsDetectorLoss</span>
<span class="kn">from</span> <span class="nn">...volume</span> <span class="kn">import</span> <span class="n">AbsDetectorLayer</span><span class="p">,</span> <span class="n">PanelDetectorLayer</span><span class="p">,</span> <span class="n">Volume</span>
<span class="kn">from</span> <span class="nn">..callbacks</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Callback</span><span class="p">,</span>
    <span class="n">CyclicCallback</span><span class="p">,</span>
    <span class="n">EvalMetric</span><span class="p">,</span>
    <span class="n">MetricLogger</span><span class="p">,</span>
    <span class="n">PredHandler</span><span class="p">,</span>
    <span class="n">WarmupCallback</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">..data</span> <span class="kn">import</span> <span class="n">PassiveYielder</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;FitParams&quot;</span><span class="p">,</span> <span class="s2">&quot;AbsVolumeWrapper&quot;</span><span class="p">,</span> <span class="s2">&quot;PanelVolumeWrapper&quot;</span><span class="p">,</span> <span class="s2">&quot;HeatMapVolumeWrapper&quot;</span><span class="p">,</span> <span class="s2">&quot;ArbVolumeWrapper&quot;</span><span class="p">]</span>

<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Provides wrapper classes for optimising detectors and other quality-of-life methods</span>

<span class="sd">FitParams and AbsVolumeWrapper are modified versions of the FitParams in LUMIN (https://github.com/GilesStrong/lumin/blob/v0.7.2/lumin/nn/models/abs_model.py#L16)</span>
<span class="sd">and Model in LUMIN (https://github.com/GilesStrong/lumin/blob/master/lumin/nn/models/model.py#L32), distributed under the following licence:</span>
<span class="sd">    Copyright 2018 onwards Giles Strong</span>

<span class="sd">    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="sd">    you may not use this file except in compliance with the License.</span>
<span class="sd">    You may obtain a copy of the License at</span>

<span class="sd">       http://www.apache.org/licenses/LICENSE-2.0</span>

<span class="sd">    Unless required by applicable law or agreed to in writing, software</span>
<span class="sd">    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="sd">    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="sd">    See the License for the specific language governing permissions and</span>
<span class="sd">    limitations under the License.</span>

<span class="sd">Usage is compatible with the AGPL licence under-which TomOpt is distributed.</span>
<span class="sd">Stated changes: adaption of FitParams to pass type-checking, heavy adaptation of Model to be suitable for task specific training</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="FitParams"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.FitParams">[docs]</a><span class="k">class</span> <span class="nc">FitParams</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Data class used for storing all aspects of optimisation and prediction when working with</span>
<span class="sd">    :class:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper`</span>

<span class="sd">    Arguments:</span>
<span class="sd">        kwargs: objects to be stored</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">volume_inferrer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbsVolumeInferrer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">pred</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">n_mu_per_volume</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">mu_bs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">mu</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MuonBatch</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">cbs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Callback</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">sb</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ScatterBatch</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">loss_val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">volume_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">cb_savepath</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Path</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">trn_passives</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PassiveYielder</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">val_passives</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PassiveYielder</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">tst_passives</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PassiveYielder</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">passive_bs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">mean_loss</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">n_epochs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">epoch_bar</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ProgressBar</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">stop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">epoch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cyclic_cbs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">CyclicCallback</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">warmup_cbs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">WarmupCallback</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">metric_log</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MetricLogger</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">metric_cbs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">EvalMetric</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">passive_bar</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">NBProgressBar</span><span class="p">,</span> <span class="n">ConsoleProgressBar</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">DEVICE</span>
    <span class="n">skip_opt_step</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stores any keyword arguments as an attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="AbsVolumeWrapper"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper">[docs]</a><span class="k">class</span> <span class="nc">AbsVolumeWrapper</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for optimisation volume wrappers.</span>
<span class="sd">    Inheriting classes will need to override :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper._build_opt`</span>
<span class="sd">    according to the detector parameters that need to be optimised.</span>

<span class="sd">    Volume wrappers are designed to contain a :class:`~tomopt.volume.volume.Volume` and provide means of optimising the detectors it contains,</span>
<span class="sd">    via their :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper.fit` method.</span>

<span class="sd">    Wrappers also provide for various quality-of-life methods, such as saving and loading detector configurations,</span>
<span class="sd">    and computing predictions with a fixed detector (:meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper.predict`)</span>

<span class="sd">    Fitting of a detector proceeds as training and validation epochs, each of which contains multiple batches of passive volumes.</span>
<span class="sd">    For each volume in a batch, the loss is evaluated using multiple batches of muons.</span>
<span class="sd">    The whole loop is:</span>

<span class="sd">    1. for epoch in `n_epochs`:</span>
<span class="sd">        A. `loss` = 0</span>
<span class="sd">        B. for `p`, `passive` in enumerate(`trn_passives`):</span>
<span class="sd">            a. load `passive` into passive volume</span>
<span class="sd">            b. for muon_batch in range(`n_mu_per_volume`//`mu_bs`):</span>
<span class="sd">                i. Irradiate volume with `mu_bs` muons</span>
<span class="sd">                ii. Infer passive volume</span>
<span class="sd">            c. Compute loss based on precision and cost, and add to `loss`</span>
<span class="sd">            d. if `p`+1 % `passive_bs` == 0:</span>
<span class="sd">                i. `loss` = `loss`/`passive_bs`</span>
<span class="sd">                ii. Backpropagate `loss` and update detector parameters</span>
<span class="sd">                iii. `loss` = 0</span>
<span class="sd">            e. if len(`trn_passives`)-(`p`+1) &lt; `passive_bs`:</span>
<span class="sd">                i. Break</span>

<span class="sd">        C. `val_loss` = 0</span>
<span class="sd">        D. for `p`, `passive` in enumerate(`val_passives`):</span>
<span class="sd">            a. load `passive` into passive volume</span>
<span class="sd">            b. for muon_batch in range(`n_mu_per_volume`//`mu_bs`):</span>
<span class="sd">                i. Irradiate volume with `mu_bs` muons</span>
<span class="sd">                ii. Infer passive volume</span>
<span class="sd">                iii. Compute loss based on precision and cost, and add to `val_loss`</span>
<span class="sd">            c. if len(`val_passives`)-(`p`+1) &lt; `passive_bs`:</span>
<span class="sd">                i. Break</span>
<span class="sd">        E. `val_loss` = `val_loss`/`p`</span>

<span class="sd">    In implementation, the loop is broken up into several functions:</span>
<span class="sd">        - :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper._fit_epoch` runs one full epoch of volumes and updates for both training and validation</span>
<span class="sd">        - :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper._scan_volumes` runs over all training/validation volumes, updating parameters when necessary</span>
<span class="sd">        - :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper._scan_volume` irradiates a single volume with muons multiple batches, and computes the loss for that volume</span>

<span class="sd">    The optimisation and prediction loops are supported by a stateful callback mechanism.</span>
<span class="sd">    The base callback is :class:`~tomopt.optimisation.callbacks.callback.Callback`, which can interject at various points in the loops.</span>
<span class="sd">    All aspects of the optimisation and prediction are stored in a :class:`~tomopt.optimisation.wrapper.volume_wrapper.FitParams` data class,</span>
<span class="sd">    since the callbacks are also stored there, and the callbacks have a reference to the wrapper, they are able to read/write to the `FitParams` and be</span>
<span class="sd">    aware of other callbacks that are running.</span>

<span class="sd">    Accounting for the interjection calls (`on_*_begin` &amp; `on_*_end`), the full optimisation loop is:</span>

<span class="sd">    1. Associate callbacks with wrapper (`set_wrapper`)</span>
<span class="sd">    2. `on_train_begin`</span>
<span class="sd">    3. for epoch in `n_epochs`:</span>
<span class="sd">        A. `state` = &quot;train&quot;</span>
<span class="sd">        B. `on_epoch_begin`</span>
<span class="sd">        C. for `p`, `passive` in enumerate(`trn_passives`):</span>
<span class="sd">            a. if `p` % `passive_bs` == 0:</span>
<span class="sd">                i. `on_volume_batch_begin`</span>
<span class="sd">                ii. `loss` = 0</span>
<span class="sd">            b. load `passive` into passive volume</span>
<span class="sd">            c. `on_volume_begin`</span>
<span class="sd">            d. for muon_batch in range(`n_mu_per_volume`//`mu_bs`):</span>
<span class="sd">                i. `on_mu_batch_begin`</span>
<span class="sd">                ii. Irradiate volume with `mu_bs` muons</span>
<span class="sd">                iii. Infer scatter locations</span>
<span class="sd">                iv. `on_scatter_end`</span>
<span class="sd">                v. Infer x0 and append to list of x0 predictions</span>
<span class="sd">                vi. `on_mu_batch_end`</span>
<span class="sd">            e. `on_x0_pred_begin`</span>
<span class="sd">            f. Compute overall x0 prediction</span>
<span class="sd">            g. `on_x0_pred_end`</span>
<span class="sd">            h. Compute loss based on precision and cost, and add to `loss`</span>
<span class="sd">            i. if `p`+1 % `passive_bs` == 0:</span>
<span class="sd">                i. `loss` = `loss`/`passive_bs`</span>
<span class="sd">                ii. `on_volume_batch_end`</span>
<span class="sd">                iii. Zero parameter gradients</span>
<span class="sd">                iv. `on_backwards_begin`</span>
<span class="sd">                v. Backpropagate `loss` and compute parameter gradients</span>
<span class="sd">                vi. `on_backwards_end`</span>
<span class="sd">                vii. Update detector parameters</span>
<span class="sd">                viii. Ensure detector parameters are within physical boundaries (`AbsDetectorLayer.conform_detector`)</span>
<span class="sd">                viv. `loss` = 0</span>
<span class="sd">            j. if len(`trn_passives`)-(`p`+1) &lt; `passive_bs`:</span>
<span class="sd">                i. Break</span>
<span class="sd">        D. `on_epoch_end`</span>
<span class="sd">        E. `state` = &quot;valid&quot;</span>
<span class="sd">        F. `on_epoch_begin`</span>
<span class="sd">        G. for `p`, `passive` in enumerate(`val_passives`):</span>
<span class="sd">            a. if `p` % `passive_bs` == 0:</span>
<span class="sd">                i. `on_volume_batch_begin`</span>
<span class="sd">                ii. `loss` = 0</span>
<span class="sd">            b. `on_volume_begin`</span>
<span class="sd">            c. for muon_batch in range(`n_mu_per_volume`//`mu_bs`):</span>
<span class="sd">                i. `on_mu_batch_begin`</span>
<span class="sd">                ii. Irradiate volume with `mu_bs` muons</span>
<span class="sd">                iii. Infer scatter locations</span>
<span class="sd">                iv. `on_scatter_end`</span>
<span class="sd">                v. Infer x0 and append to list of x0 predictions</span>
<span class="sd">                vi. `on_mu_batch_end`</span>
<span class="sd">            d. `on_x0_pred_begin`</span>
<span class="sd">            e. Compute overall x0 prediction</span>
<span class="sd">            f. `on_x0_pred_end`</span>
<span class="sd">            g. Compute loss based on precision and cost, and add to `loss`</span>
<span class="sd">            h. if `p`+1 % `passive_bs` == 0:</span>
<span class="sd">                i. `loss` = `loss`/`passive_bs`</span>
<span class="sd">                ii. `on_volume_batch_end`</span>
<span class="sd">            i. if len(`val_passives`)-(`p`+1) &lt; `passive_bs`:</span>
<span class="sd">                i. Break</span>
<span class="sd">        H. `on_epoch_end`</span>
<span class="sd">    4. `on_train_end`</span>

<span class="sd">    Arguments:</span>
<span class="sd">        volume: the volume containing the detectors to be optimised</span>
<span class="sd">        partial_opts: dictionary of uninitialised optimisers to be associated with the detector parameters, via `_build_opt`</span>
<span class="sd">        loss_func: Optional loss function (required if planning to optimise the detectors)</span>
<span class="sd">        partial_scatter_inferrer: uninitialised class to be used for inferring muon scatter variables and trajectories</span>
<span class="sd">        partial_volume_inferrer:  uninitialised class to be used for inferring volume targets</span>
<span class="sd">        mu_generator: Optional generator class for muons. If None, will use :meth:`~tomopt.muon.generation. MuonGenerator2016.from_volume`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">opts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">volume</span><span class="p">:</span> <span class="n">Volume</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">partial_opts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PartialOpt</span><span class="p">],</span>
        <span class="n">loss_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbsDetectorLoss</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">partial_scatter_inferrer</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">ScatterBatch</span><span class="p">],</span>
        <span class="n">partial_volume_inferrer</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">AbsVolumeInferrer</span><span class="p">],</span>
        <span class="n">mu_generator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbsMuonGenerator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_func</span> <span class="o">=</span> <span class="n">volume</span><span class="p">,</span> <span class="n">loss_func</span>
        <span class="k">if</span> <span class="n">mu_generator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mu_generator</span> <span class="o">=</span> <span class="n">MuonGenerator2016</span><span class="o">.</span><span class="n">from_volume</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu_generator</span> <span class="o">=</span> <span class="n">mu_generator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">partial_scatter_inferrer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial_volume_inferrer</span> <span class="o">=</span> <span class="n">partial_scatter_inferrer</span><span class="p">,</span> <span class="n">partial_volume_inferrer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_opt</span><span class="p">(</span><span class="o">**</span><span class="n">partial_opts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">parameters</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_build_opt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inheriting classes should override this method to initialise the optimisers by associating them to the detector parameters. e.g.:</span>
<span class="sd">        self.opts = {&#39;res_opt&#39;: res_opt((l.resolution for l in self.volume.get_detectors())),</span>
<span class="sd">                     &#39;eff_opt&#39;: eff_opt((l.efficiency for l in self.volume.get_detectors()))}</span>

<span class="sd">        Arguments:</span>
<span class="sd">            kwargs: uninitialised optimisers passed as keyword arguments</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">pass</span>

<div class="viewcode-block" id="AbsVolumeWrapper.get_detectors"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper.get_detectors">[docs]</a>    <span class="k">def</span> <span class="nf">get_detectors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">AbsDetectorLayer</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            A list of all :class:`~tomopt.volume.layer.AbsDetectorLayer` s in the volume, in the order of `layers` (normally decreasing z position)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">get_detectors</span><span class="p">()</span></div>

<div class="viewcode-block" id="AbsVolumeWrapper.save"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves the volume and optimiser parameters to a file.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            name: savename for the file</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">({</span><span class="s2">&quot;volume&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">state_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opts</span><span class="o">.</span><span class="n">items</span><span class="p">()}},</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbsVolumeWrapper.load"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads saved volume and optimiser parameters from a file.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            name: file to load</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">state</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">map_location</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;volume&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;budget_weights&quot;</span> <span class="ow">in</span> <span class="n">state</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">assign_budget</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;_opt&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">opts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbsVolumeWrapper.get_param_count"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper.get_param_count">[docs]</a>    <span class="k">def</span> <span class="nf">get_param_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trainable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return number of parameters in detector.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            trainable: if true (default) only count trainable parameters</span>

<span class="sd">        Returns:</span>
<span class="sd">            Number of (trainable) parameters in detector</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">requires_grad</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">trainable</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbsVolumeWrapper.fit"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_epochs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">passive_bs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">n_mu_per_volume</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">mu_bs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">trn_passives</span><span class="p">:</span> <span class="n">PassiveYielder</span><span class="p">,</span>
        <span class="n">val_passives</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PassiveYielder</span><span class="p">],</span>
        <span class="n">cbs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Callback</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cb_savepath</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;train_weights&quot;</span><span class="p">),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Callback</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs the fitting loop for the detectors over a specified number of epochs, using the provided volumes or volume generators.</span>
<span class="sd">        The optimisation loop can be supported by callbacks.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            n_epochs: number of epochs to run for (a training and validation epoch only counts as one &#39;epoch)</span>
<span class="sd">            passive_bs: number of passive volumes to use per volume batch (detector updates occur after every volume batch in training mode)</span>
<span class="sd">            n_mu_per_volume: number of muons to use in total when inferring the target of a single volume</span>
<span class="sd">            mu_bs: number of muons to use per muon batch; multiple muon batches will be used until `n_mu_per_volume` is reached</span>
<span class="sd">            trn_passives: passive volumes to use for optimising the detector</span>
<span class="sd">            val_passives: optional passive volumes to use for evaluating the detector</span>
<span class="sd">            cbs: optional list of callbacks to use</span>
<span class="sd">            cb_savepath: location where callbacks should write/save any information</span>

<span class="sd">        Returns:</span>
<span class="sd">            The list of callbacks</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">cbs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cbs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sorted_cbs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_cbs</span><span class="p">(</span><span class="n">cbs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span> <span class="o">=</span> <span class="n">FitParams</span><span class="p">(</span>
            <span class="n">cbs</span><span class="o">=</span><span class="n">cbs</span><span class="p">,</span>
            <span class="n">cyclic_cbs</span><span class="o">=</span><span class="n">sorted_cbs</span><span class="p">[</span><span class="s2">&quot;cyclic_cbs&quot;</span><span class="p">],</span>
            <span class="n">warmup_cbs</span><span class="o">=</span><span class="n">sorted_cbs</span><span class="p">[</span><span class="s2">&quot;warmup_cbs&quot;</span><span class="p">],</span>
            <span class="n">metric_log</span><span class="o">=</span><span class="n">sorted_cbs</span><span class="p">[</span><span class="s2">&quot;metric_log&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">metric_cbs</span><span class="o">=</span><span class="n">sorted_cbs</span><span class="p">[</span><span class="s2">&quot;metric_cbs&quot;</span><span class="p">],</span>
            <span class="n">stop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">n_epochs</span><span class="o">=</span><span class="n">n_epochs</span><span class="p">,</span>
            <span class="n">mu_bs</span><span class="o">=</span><span class="n">mu_bs</span><span class="p">,</span>
            <span class="n">n_mu_per_volume</span><span class="o">=</span><span class="n">n_mu_per_volume</span><span class="p">,</span>
            <span class="n">cb_savepath</span><span class="o">=</span><span class="n">Path</span><span class="p">(</span><span class="n">cb_savepath</span><span class="p">),</span>
            <span class="n">trn_passives</span><span class="o">=</span><span class="n">trn_passives</span><span class="p">,</span>
            <span class="n">val_passives</span><span class="o">=</span><span class="n">val_passives</span><span class="p">,</span>
            <span class="n">passive_bs</span><span class="o">=</span><span class="n">passive_bs</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cb_savepath</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">set_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">on_train_begin</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">epoch_bar</span> <span class="o">=</span> <span class="n">progress_bar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">n_epochs</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">epoch_bar</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fit_epoch</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">stop</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">on_train_end</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">empty_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cbs</span></div>

<div class="viewcode-block" id="AbsVolumeWrapper.predict"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper.predict">[docs]</a>    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">passives</span><span class="p">:</span> <span class="n">PassiveYielder</span><span class="p">,</span>
        <span class="n">n_mu_per_volume</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">mu_bs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">pred_cb</span><span class="p">:</span> <span class="n">PredHandler</span> <span class="o">=</span> <span class="n">PredHandler</span><span class="p">(),</span>
        <span class="n">cbs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Callback</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cb_savepath</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;train_weights&quot;</span><span class="p">),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses the detectors to predict the provided volumes</span>
<span class="sd">        The prediction loop can be supported by callbacks.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            passives: passive volumes to predict</span>
<span class="sd">            n_mu_per_volume: number of muons to use in total when inferring the target of a single volume</span>
<span class="sd">            mu_bs: number of muons to use per muon batch; multiple muon batches will be used until n_mu_per_volume is reached</span>
<span class="sd">            pred_cb: the prediction callback to use for recording predictions</span>
<span class="sd">            cbs: optional list of callbacks to use</span>
<span class="sd">            cb_savepath: location where callbacks should write/save any information</span>

<span class="sd">        Returns:</span>
<span class="sd">            The object returned by the `pred_cb`&#39;s `get_preds` method</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">cbs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cbs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred_cb</span><span class="p">)</span>
        <span class="n">passives</span><span class="o">.</span><span class="n">shuffle</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span> <span class="o">=</span> <span class="n">FitParams</span><span class="p">(</span>
            <span class="n">n_mu_per_volume</span><span class="o">=</span><span class="n">n_mu_per_volume</span><span class="p">,</span>
            <span class="n">mu_bs</span><span class="o">=</span><span class="n">mu_bs</span><span class="p">,</span>
            <span class="n">cbs</span><span class="o">=</span><span class="n">cbs</span><span class="p">,</span>
            <span class="n">tst_passives</span><span class="o">=</span><span class="n">passives</span><span class="p">,</span>
            <span class="n">state</span><span class="o">=</span><span class="s2">&quot;test&quot;</span><span class="p">,</span>
            <span class="n">cb_savepath</span><span class="o">=</span><span class="n">cb_savepath</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">set_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">on_pred_begin</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scan_volumes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">tst_passives</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">on_pred_end</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">cbs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># Remove pred_cb to avoid mutating cbs</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">empty_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pred_cb</span><span class="o">.</span><span class="n">get_preds</span><span class="p">()</span></div>

<div class="viewcode-block" id="AbsVolumeWrapper.get_opt_lr"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper.get_opt_lr">[docs]</a>    <span class="k">def</span> <span class="nf">get_opt_lr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opt</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the learning rate of the specified optimiser.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            opt: string name of the optimiser requested</span>

<span class="sd">        Returns:</span>
<span class="sd">            The learning rate of the specified optimiser</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opts</span><span class="p">[</span><span class="n">opt</span><span class="p">]</span><span class="o">.</span><span class="n">param_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;lr&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="AbsVolumeWrapper.set_opt_lr"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper.set_opt_lr">[docs]</a>    <span class="k">def</span> <span class="nf">set_opt_lr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lr</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">opt</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the learning rate of the specified optimiser.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            lr: new learning rate for the optimiser</span>
<span class="sd">            opt: string name of the optimiser requested</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">opts</span><span class="p">[</span><span class="n">opt</span><span class="p">]</span><span class="o">.</span><span class="n">param_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;lr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lr</span></div>

<div class="viewcode-block" id="AbsVolumeWrapper.get_opt_mom"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper.get_opt_mom">[docs]</a>    <span class="k">def</span> <span class="nf">get_opt_mom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opt</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the momentum coefficient/beta_1 of the specified optimiser.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            opt: string name of the optimiser requested</span>

<span class="sd">        Returns:</span>
<span class="sd">            The momentum coefficient/beta_1 of the specified optimiser</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;betas&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opts</span><span class="p">[</span><span class="n">opt</span><span class="p">]</span><span class="o">.</span><span class="n">param_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opts</span><span class="p">[</span><span class="n">opt</span><span class="p">]</span><span class="o">.</span><span class="n">param_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;betas&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opts</span><span class="p">[</span><span class="n">opt</span><span class="p">]</span><span class="o">.</span><span class="n">param_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;momentum&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="AbsVolumeWrapper.set_opt_mom"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper.set_opt_mom">[docs]</a>    <span class="k">def</span> <span class="nf">set_opt_mom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mom</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">opt</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the learning rate of the specified optimiser.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            mom: new momentum coefficient/beta_1 for the optimiser</span>
<span class="sd">            opt: string name of the optimiser requested</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;betas&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opts</span><span class="p">[</span><span class="n">opt</span><span class="p">]</span><span class="o">.</span><span class="n">param_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opts</span><span class="p">[</span><span class="n">opt</span><span class="p">]</span><span class="o">.</span><span class="n">param_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;betas&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">opts</span><span class="p">[</span><span class="n">opt</span><span class="p">]</span><span class="o">.</span><span class="n">param_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;betas&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opts</span><span class="p">[</span><span class="n">opt</span><span class="p">]</span><span class="o">.</span><span class="n">param_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;momentum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mom</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sort_cbs</span><span class="p">(</span><span class="n">cbs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Callback</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Callback</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts callbacks into lists according to their type and whether other callbacks might need to be aware of them.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            cbs: all callbacks being used</span>

<span class="sd">        Returns:</span>
<span class="sd">            cyclical callbacks: list of callbacks that act over a range of epochs</span>
<span class="sd">            logger callbacks: list of callbacks that record telemetry of the optimisation process</span>
<span class="sd">            metric: list of callbacks that compute performance metrics about the detector</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sorted_cbs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Callback</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">n_warmup</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cbs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">CyclicCallback</span><span class="p">):</span>
                <span class="n">sorted_cbs</span><span class="p">[</span><span class="s2">&quot;cyclic_cbs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>  <span class="c1"># CBs that might prevent a wrapper from stopping training due to a hyper-param cycle</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">WarmupCallback</span><span class="p">):</span>
                <span class="n">sorted_cbs</span><span class="p">[</span><span class="s2">&quot;warmup_cbs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>  <span class="c1"># CBs that might act on a warmup cycle whilst optimisation is frozen</span>
                <span class="n">n_warmup</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span class="n">n_warmup</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">MetricLogger</span><span class="p">):</span>
                <span class="n">sorted_cbs</span><span class="p">[</span><span class="s2">&quot;metric_log&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>  <span class="c1"># CB that logs losses and eval_metrics</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">EvalMetric</span><span class="p">):</span>
                <span class="n">sorted_cbs</span><span class="p">[</span><span class="s2">&quot;metric_cbs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>  <span class="c1"># CBs that computes additional performance metrics</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_cbs</span><span class="p">[</span><span class="s2">&quot;warmup_cbs&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1"> warmup callbacks found, with a total warmup period of </span><span class="si">{</span><span class="n">n_warmup</span><span class="si">}</span><span class="s1"> epochs.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_cbs</span><span class="p">[</span><span class="s2">&quot;metric_log&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sorted_cbs</span><span class="p">[</span><span class="s2">&quot;metric_log&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sorted_cbs</span>

    <span class="k">def</span> <span class="nf">_fit_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs through one training epoch (state = &#39;train&#39;), using :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper._scan_volumes`.</span>
<span class="sd">        If validation volumes are present, will then run through one validation epoch (state = &#39;valid&#39;),</span>
<span class="sd">        again using :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper._scan_volumes`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">run_epoch</span><span class="p">(</span><span class="n">passives</span><span class="p">:</span> <span class="n">PassiveYielder</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">on_epoch_begin</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scan_volumes</span><span class="p">(</span><span class="n">passives</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">on_epoch_end</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">epoch</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Training</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;train&quot;</span>
        <span class="n">run_epoch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">trn_passives</span><span class="p">)</span>

        <span class="c1"># Validation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">val_passives</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;valid&quot;</span>
            <span class="n">run_epoch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">val_passives</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_scan_volumes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">passives</span><span class="p">:</span> <span class="n">PassiveYielder</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scans all volumes by splitting them into volume batches.</span>
<span class="sd">        Each volume is scanned via using :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper._scan_volume`.</span>
<span class="sd">        After each volume batch, if in &#39;train&#39; state,the detector parameters will be updated using the loss of the volume batch and the optimisers.</span>
<span class="sd">            If not enough volumes remain to form a complete batch and in &#39;train&#39; state, the method will end prematurely.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s2">&quot;test&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">passive_bar</span> <span class="o">=</span> <span class="n">master_bar</span><span class="p">(</span><span class="n">passives</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">passive</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">passive_bar</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s2">&quot;test&quot;</span> <span class="k">else</span> <span class="n">passives</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">volume_id</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="s2">&quot;test&quot;</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">passive_bs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Volume batch start</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">loss_val</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">on_volume_batch_begin</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">load_rad_length</span><span class="p">(</span><span class="n">passive</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">on_volume_begin</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scan_volume</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">on_volume_end</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="s2">&quot;test&quot;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">passive_bs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Volume batch end</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">loss_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">mean_loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">loss_val</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">passive_bs</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">mean_loss</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">on_volume_batch_end</span><span class="p">()</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="s2">&quot;train&quot;</span><span class="p">:</span>
                    <span class="c1"># Compute update step</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opts</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="n">o</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">on_backwards_begin</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">mean_loss</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">mean_loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">on_backwards_end</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">mean_loss</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">skip_opt_step</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">opts</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                            <span class="n">o</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">on_step_end</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">get_detectors</span><span class="p">():</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">conform_detector</span><span class="p">()</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">passives</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">passive_bs</span><span class="p">:</span>
                    <span class="k">break</span>

    <span class="k">def</span> <span class="nf">_scan_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Passes multiple batches of muons through a single volume, and infers the volume target.</span>
<span class="sd">        If in &#39;train&#39; or &#39;valid&#39; state, also computes the loss on the detector.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Scan volume with muon batches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">pred</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="s2">&quot;test&quot;</span><span class="p">:</span>
            <span class="n">muon_bar</span> <span class="o">=</span> <span class="n">progress_bar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">n_mu_per_volume</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">mu_bs</span><span class="p">),</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">muon_bar</span> <span class="o">=</span> <span class="n">progress_bar</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">n_mu_per_volume</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">mu_bs</span><span class="p">),</span> <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">passive_bar</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">volume_inferrer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial_volume_inferrer</span><span class="p">(</span><span class="n">volume</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">muon_bar</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">MuonBatch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu_generator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">mu_bs</span><span class="p">),</span> <span class="n">init_z</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">on_mu_batch_begin</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">sb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partial_scatter_inferrer</span><span class="p">(</span><span class="n">mu</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">on_scatter_end</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">volume_inferrer</span><span class="o">.</span><span class="n">add_scatters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">sb</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
                <span class="n">c</span><span class="o">.</span><span class="n">on_mu_batch_end</span><span class="p">()</span>

        <span class="c1"># Predict volume based on all muon batches</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">on_x0_pred_begin</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">volume_inferrer</span><span class="o">.</span><span class="n">get_prediction</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">cbs</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">on_x0_pred_end</span><span class="p">()</span>

        <span class="c1"># Compute loss for volume</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="s2">&quot;test&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">pred</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_func</span><span class="p">(</span><span class="n">pred</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">pred</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">loss_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">loss_val</span> <span class="o">=</span> <span class="n">loss</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">loss_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="o">.</span><span class="n">loss_val</span> <span class="o">+</span> <span class="n">loss</span></div>


<div class="viewcode-block" id="PanelVolumeWrapper"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.PanelVolumeWrapper">[docs]</a><span class="k">class</span> <span class="nc">PanelVolumeWrapper</span><span class="p">(</span><span class="n">AbsVolumeWrapper</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Volume wrapper for volumes with :class:`~tomopt.volume.panel.DetectorPanel`-based detectors.</span>

<span class="sd">    Volume wrappers are designed to contain a :class:`~tomopt.volume.volume.Volume` and provide means of optimising the detectors it contains,</span>
<span class="sd">    via their :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper.fit` method.</span>

<span class="sd">    Wrappers also provide for various quality-of-life methods, such as saving and loading detector configurations,</span>
<span class="sd">    and computing predictions with a fixed detector (:meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper.predict`)</span>

<span class="sd">    Fitting of a detector proceeds as training and validation epochs, each of which contains multiple batches of passive volumes.</span>
<span class="sd">    For each volume in a batch, the loss is evaluated using multiple batches of muons.</span>
<span class="sd">    The whole loop is:</span>

<span class="sd">    1. for epoch in `n_epochs`:</span>
<span class="sd">        A. `loss` = 0</span>
<span class="sd">        B. for `p`, `passive` in enumerate(`trn_passives`):</span>
<span class="sd">            a. load `passive` into passive volume</span>
<span class="sd">            b. for muon_batch in range(`n_mu_per_volume`//`mu_bs`):</span>
<span class="sd">                i. Irradiate volume with `mu_bs` muons</span>
<span class="sd">                ii. Infer passive volume</span>
<span class="sd">            c. Compute loss based on precision and cost, and add to `loss`</span>
<span class="sd">            d. if `p`+1 % `passive_bs` == 0:</span>
<span class="sd">                i. `loss` = `loss`/`passive_bs`</span>
<span class="sd">                ii. Backpropagate `loss` and update detector parameters</span>
<span class="sd">                iii. `loss` = 0</span>
<span class="sd">            e. if len(`trn_passives`)-(`p`+1) &lt; `passive_bs`:</span>
<span class="sd">                i. Break</span>

<span class="sd">        C. `val_loss` = 0</span>
<span class="sd">        D. for `p`, `passive` in enumerate(`val_passives`):</span>
<span class="sd">            a. load `passive` into passive volume</span>
<span class="sd">            b. for muon_batch in range(`n_mu_per_volume`//`mu_bs`):</span>
<span class="sd">                i. Irradiate volume with `mu_bs` muons</span>
<span class="sd">                ii. Infer passive volume</span>
<span class="sd">                iii. Compute loss based on precision and cost, and add to `val_loss`</span>
<span class="sd">            c. if len(`val_passives`)-(`p`+1) &lt; `passive_bs`:</span>
<span class="sd">                i. Break</span>
<span class="sd">        E. `val_loss` = `val_loss`/`p`</span>

<span class="sd">    In implementation, the loop is broken up into several functions:</span>
<span class="sd">        :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper._fit_epoch` runs one full epoch of volumes</span>
<span class="sd">            and updates for both training and validation</span>
<span class="sd">        :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper._scan_volumes` runs over all training/validation volumes,</span>
<span class="sd">            updating parameters when necessary</span>
<span class="sd">        :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper._scan_volume` irradiates a single volume with muons multiple batches,</span>
<span class="sd">            and computes the loss for that volume</span>

<span class="sd">    The optimisation and prediction loops are supported by a stateful callback mechanism.</span>
<span class="sd">    The base callback is :class:`~tomopt.optimisation.callbacks.callback.Callback`, which can interject at various points in the loops.</span>
<span class="sd">    All aspects of the optimisation and prediction are stored in a :class:`~tomopt.optimisation.wrapper.volume_wrapper.FitParams` data class,</span>
<span class="sd">    since the callbacks are also stored there, and the callbacks have a reference to the wrapper, they are able to read/write to the `FitParams` and be</span>
<span class="sd">    aware of other callbacks that are running.</span>

<span class="sd">    Accounting for the interjection calls (`on_*_begin` &amp; `on_*_end`), the full optimisation loop is:</span>

<span class="sd">    1. Associate callbacks with wrapper (`set_wrapper`)</span>
<span class="sd">    2. `on_train_begin`</span>
<span class="sd">    3. for epoch in `n_epochs`:</span>
<span class="sd">        A. `state` = &quot;train&quot;</span>
<span class="sd">        B. `on_epoch_begin`</span>
<span class="sd">        C. for `p`, `passive` in enumerate(`trn_passives`):</span>
<span class="sd">            a. if `p` % `passive_bs` == 0:</span>
<span class="sd">                i. `on_volume_batch_begin`</span>
<span class="sd">                ii. `loss` = 0</span>
<span class="sd">            b. load `passive` into passive volume</span>
<span class="sd">            c. `on_volume_begin`</span>
<span class="sd">            d. for muon_batch in range(`n_mu_per_volume`//`mu_bs`):</span>
<span class="sd">                i. `on_mu_batch_begin`</span>
<span class="sd">                ii. Irradiate volume with `mu_bs` muons</span>
<span class="sd">                iii. Infer scatter locations</span>
<span class="sd">                iv. `on_scatter_end`</span>
<span class="sd">                v. Infer x0 and append to list of x0 predictions</span>
<span class="sd">                vi. `on_mu_batch_end`</span>
<span class="sd">            e. `on_x0_pred_begin`</span>
<span class="sd">            f. Compute overall x0 prediction</span>
<span class="sd">            g. `on_x0_pred_end`</span>
<span class="sd">            h. Compute loss based on precision and cost, and add to `loss`</span>
<span class="sd">            i. if `p`+1 % `passive_bs` == 0:</span>
<span class="sd">                i. `loss` = `loss`/`passive_bs`</span>
<span class="sd">                ii. `on_volume_batch_end`</span>
<span class="sd">                iii. Zero parameter gradients</span>
<span class="sd">                iv. `on_backwards_begin`</span>
<span class="sd">                v. Backpropagate `loss` and compute parameter gradients</span>
<span class="sd">                vi. `on_backwards_end`</span>
<span class="sd">                vii. Update detector parameters</span>
<span class="sd">                viii. Ensure detector parameters are within physical boundaries (`AbsDetectorLayer.conform_detector`)</span>
<span class="sd">                viv. `loss` = 0</span>
<span class="sd">            j. if len(`trn_passives`)-(`p`+1) &lt; `passive_bs`:</span>
<span class="sd">                i. Break</span>
<span class="sd">        D. `on_epoch_end`</span>
<span class="sd">        E. `state` = &quot;valid&quot;</span>
<span class="sd">        F. `on_epoch_begin`</span>
<span class="sd">        G. for `p`, `passive` in enumerate(`val_passives`):</span>
<span class="sd">            a. if `p` % `passive_bs` == 0:</span>
<span class="sd">                i. `on_volume_batch_begin`</span>
<span class="sd">                ii. `loss` = 0</span>
<span class="sd">            b. `on_volume_begin`</span>
<span class="sd">            c. for muon_batch in range(`n_mu_per_volume`//`mu_bs`):</span>
<span class="sd">                i. `on_mu_batch_begin`</span>
<span class="sd">                ii. Irradiate volume with `mu_bs` muons</span>
<span class="sd">                iii. Infer scatter locations</span>
<span class="sd">                iv. `on_scatter_end`</span>
<span class="sd">                v. Infer x0 and append to list of x0 predictions</span>
<span class="sd">                vi. `on_mu_batch_end`</span>
<span class="sd">            d. `on_x0_pred_begin`</span>
<span class="sd">            e. Compute overall x0 prediction</span>
<span class="sd">            f. `on_x0_pred_end`</span>
<span class="sd">            g. Compute loss based on precision and cost, and add to `loss`</span>
<span class="sd">            h. if `p`+1 % `passive_bs` == 0:</span>
<span class="sd">                i. `loss` = `loss`/`passive_bs`</span>
<span class="sd">                ii. `on_volume_batch_end`</span>
<span class="sd">            i. if len(`val_passives`)-(`p`+1) &lt; `passive_bs`:</span>
<span class="sd">                i. Break</span>
<span class="sd">        H. `on_epoch_end`</span>
<span class="sd">    4. `on_train_end`</span>

<span class="sd">    Arguments:</span>
<span class="sd">        volume: the volume containing the detectors to be optimised</span>
<span class="sd">        xy_pos_opt: uninitialised optimiser to be used for adjusting the xy position of panels</span>
<span class="sd">        z_pos_opt: uninitialised optimiser to be used for adjusting the z position of panels</span>
<span class="sd">        xy_span_opt: uninitialised optimiser to be used for adjusting the xy size of panels</span>
<span class="sd">        budget_opt: optional uninitialised optimiser to be used for adjusting the fractional assignment of budget to the panels</span>
<span class="sd">        loss_func: optional loss function (required if planning to optimise the detectors)</span>
<span class="sd">        partial_scatter_inferrer: uninitialised class to be used for inferring muon scatter variables and trajectories</span>
<span class="sd">        partial_volume_inferrer:  uninitialised class to be used for inferring volume targets</span>
<span class="sd">        mu_generator: Optional generator class for muons. If None, will use :meth:`~tomopt.muon.generation. MuonGenerator2016.from_volume`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">volume</span><span class="p">:</span> <span class="n">Volume</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">xy_pos_opt</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">,</span>
        <span class="n">z_pos_opt</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">,</span>
        <span class="n">xy_span_opt</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">,</span>
        <span class="n">budget_opt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PartialOpt</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">loss_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbsDetectorLoss</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">partial_scatter_inferrer</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">ScatterBatch</span><span class="p">]</span> <span class="o">=</span> <span class="n">ScatterBatch</span><span class="p">,</span>
        <span class="n">partial_volume_inferrer</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">AbsVolumeInferrer</span><span class="p">]</span> <span class="o">=</span> <span class="n">PanelX0Inferrer</span><span class="p">,</span>
        <span class="n">mu_generator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbsMuonGenerator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span>
            <span class="n">partial_opts</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;xy_pos_opt&quot;</span><span class="p">:</span> <span class="n">xy_pos_opt</span><span class="p">,</span>
                <span class="s2">&quot;z_pos_opt&quot;</span><span class="p">:</span> <span class="n">z_pos_opt</span><span class="p">,</span>
                <span class="s2">&quot;xy_span_opt&quot;</span><span class="p">:</span> <span class="n">xy_span_opt</span><span class="p">,</span>
                <span class="s2">&quot;budget_opt&quot;</span><span class="p">:</span> <span class="n">budget_opt</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">loss_func</span><span class="o">=</span><span class="n">loss_func</span><span class="p">,</span>
            <span class="n">mu_generator</span><span class="o">=</span><span class="n">mu_generator</span><span class="p">,</span>
            <span class="n">partial_scatter_inferrer</span><span class="o">=</span><span class="n">partial_scatter_inferrer</span><span class="p">,</span>
            <span class="n">partial_volume_inferrer</span><span class="o">=</span><span class="n">partial_volume_inferrer</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="PanelVolumeWrapper.from_save"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.PanelVolumeWrapper.from_save">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_save</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">volume</span><span class="p">:</span> <span class="n">Volume</span><span class="p">,</span>
        <span class="n">xy_pos_opt</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">,</span>
        <span class="n">z_pos_opt</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">,</span>
        <span class="n">xy_span_opt</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">,</span>
        <span class="n">budget_opt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PartialOpt</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">loss_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbsDetectorLoss</span><span class="p">],</span>
        <span class="n">partial_scatter_inferrer</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">ScatterBatch</span><span class="p">]</span> <span class="o">=</span> <span class="n">ScatterBatch</span><span class="p">,</span>
        <span class="n">partial_volume_inferrer</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">AbsVolumeInferrer</span><span class="p">]</span> <span class="o">=</span> <span class="n">PanelX0Inferrer</span><span class="p">,</span>
        <span class="n">mu_generator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbsMuonGenerator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbsVolumeWrapper</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiates a new `PanelVolumeWrapper` and loads saved detector and optimiser parameters</span>

<span class="sd">        Arguments:</span>
<span class="sd">            name: file name with saved detector and optimiser parameters</span>
<span class="sd">            volume: the volume containing the detectors to be optimised</span>
<span class="sd">            xy_pos_opt: uninitialised optimiser to be used for adjusting the xy position of panels</span>
<span class="sd">            z_pos_opt: uninitialised optimiser to be used for adjusting the z position of panels,</span>
<span class="sd">            xy_span_opt: uninitialised optimiser to be used for adjusting the xy size of panels,</span>
<span class="sd">            budget_opt: optional uninitialised optimiser to be used for adjusting the fractional assignment of budget to the panels</span>
<span class="sd">            loss_func: optional loss function (required if planning to optimise the detectors)</span>
<span class="sd">            partial_scatter_inferrer: uninitialised class to be used for inferring muon scatter variables and trajectories</span>
<span class="sd">            partial_volume_inferrer:  uninitialised class to be used for inferring volume targets</span>
<span class="sd">            mu_generator: Optional generator class for muons. If None, will use :meth:`~tomopt.muon.generation. MuonGenerator2016.from_volume`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">vw</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span>
            <span class="n">xy_pos_opt</span><span class="o">=</span><span class="n">xy_pos_opt</span><span class="p">,</span>
            <span class="n">z_pos_opt</span><span class="o">=</span><span class="n">z_pos_opt</span><span class="p">,</span>
            <span class="n">xy_span_opt</span><span class="o">=</span><span class="n">xy_span_opt</span><span class="p">,</span>
            <span class="n">budget_opt</span><span class="o">=</span><span class="n">budget_opt</span><span class="p">,</span>
            <span class="n">loss_func</span><span class="o">=</span><span class="n">loss_func</span><span class="p">,</span>
            <span class="n">partial_scatter_inferrer</span><span class="o">=</span><span class="n">partial_scatter_inferrer</span><span class="p">,</span>
            <span class="n">partial_volume_inferrer</span><span class="o">=</span><span class="n">partial_volume_inferrer</span><span class="p">,</span>
            <span class="n">mu_generator</span><span class="o">=</span><span class="n">mu_generator</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">vw</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vw</span></div>

    <span class="k">def</span> <span class="nf">_build_opt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialises the optimisers by associating them to the detector parameters.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            kwargs: uninitialised optimisers passed as keyword arguments</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">all_dets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">get_detectors</span><span class="p">()</span>
        <span class="n">dets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">PanelDetectorLayer</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">all_dets</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">PanelDetectorLayer</span><span class="p">):</span>
                <span class="n">dets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opts</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;xy_pos_opt&quot;</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;xy_pos_opt&quot;</span><span class="p">]((</span><span class="n">p</span><span class="o">.</span><span class="n">xy</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">dets</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">panels</span><span class="p">)),</span>
            <span class="s2">&quot;z_pos_opt&quot;</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;z_pos_opt&quot;</span><span class="p">]((</span><span class="n">p</span><span class="o">.</span><span class="n">z</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">dets</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">panels</span><span class="p">)),</span>
            <span class="s2">&quot;xy_span_opt&quot;</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;xy_span_opt&quot;</span><span class="p">]((</span><span class="n">p</span><span class="o">.</span><span class="n">xy_span</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">dets</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">panels</span><span class="p">)),</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;budget_opt&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opts</span><span class="p">[</span><span class="s2">&quot;budget_opt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;budget_opt&quot;</span><span class="p">]((</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">budget_weights</span><span class="p">]))</span></div>


<div class="viewcode-block" id="HeatMapVolumeWrapper"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.HeatMapVolumeWrapper">[docs]</a><span class="k">class</span> <span class="nc">HeatMapVolumeWrapper</span><span class="p">(</span><span class="n">AbsVolumeWrapper</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Volume wrapper for volumes with :class:`~tomopt.volume.heatmap.DetectorHeatMap`-based detectors.</span>

<span class="sd">    Volume wrappers are designed to contain a :class:`~tomopt.volume.volume.Volume` and provide means of optimising the detectors it contains,</span>
<span class="sd">    via their :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper.fit` method.</span>

<span class="sd">    Wrappers also provide for various quality-of-life methods, such as saving and loading detector configurations,</span>
<span class="sd">    and computing predictions with a fixed detector (:meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper.predict`)</span>

<span class="sd">    Fitting of a detector proceeds as training and validation epochs, each of which contains multiple batches of passive volumes.</span>
<span class="sd">    For each volume in a batch, the loss is evaluated using multiple batches of muons.</span>
<span class="sd">    The whole loop is:</span>

<span class="sd">    1. for epoch in `n_epochs`:</span>
<span class="sd">        A. `loss` = 0</span>
<span class="sd">        B. for `p`, `passive` in enumerate(`trn_passives`):</span>
<span class="sd">            a. load `passive` into passive volume</span>
<span class="sd">            b. for muon_batch in range(`n_mu_per_volume`//`mu_bs`):</span>
<span class="sd">                i. Irradiate volume with `mu_bs` muons</span>
<span class="sd">                ii. Infer passive volume</span>
<span class="sd">            c. Compute loss based on precision and cost, and add to `loss`</span>
<span class="sd">            d. if `p`+1 % `passive_bs` == 0:</span>
<span class="sd">                i. `loss` = `loss`/`passive_bs`</span>
<span class="sd">                ii. Backpropagate `loss` and update detector parameters</span>
<span class="sd">                iii. `loss` = 0</span>
<span class="sd">            e. if len(`trn_passives`)-(`p`+1) &lt; `passive_bs`:</span>
<span class="sd">                i. Break</span>

<span class="sd">        C. `val_loss` = 0</span>
<span class="sd">        D. for `p`, `passive` in enumerate(`val_passives`):</span>
<span class="sd">            a. load `passive` into passive volume</span>
<span class="sd">            b. for muon_batch in range(`n_mu_per_volume`//`mu_bs`):</span>
<span class="sd">                i. Irradiate volume with `mu_bs` muons</span>
<span class="sd">                ii. Infer passive volume</span>
<span class="sd">                iii. Compute loss based on precision and cost, and add to `val_loss`</span>
<span class="sd">            c. if len(`val_passives`)-(`p`+1) &lt; `passive_bs`:</span>
<span class="sd">                i. Break</span>
<span class="sd">        E. `val_loss` = `val_loss`/`p`</span>

<span class="sd">    In implementation, the loop is broken up into several functions:</span>
<span class="sd">        :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper._fit_epoch` runs one full epoch of volumes</span>
<span class="sd">            and updates for both training and validation</span>
<span class="sd">        :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper._scan_volumes` runs over all training/validation volumes,</span>
<span class="sd">            updating parameters when necessary</span>
<span class="sd">        :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper._scan_volume` irradiates a single volume with muons multiple batches,</span>
<span class="sd">            and computes the loss for that volume</span>

<span class="sd">    The optimisation and prediction loops are supported by a stateful callback mechanism.</span>
<span class="sd">    The base callback is :class:`~tomopt.optimisation.callbacks.callback.Callback`, which can interject at various points in the loops.</span>
<span class="sd">    All aspects of the optimisation and prediction are stored in a :class:`~tomopt.optimisation.wrapper.volume_wrapper.FitParams` data class,</span>
<span class="sd">    since the callbacks are also stored there, and the callbacks have a reference to the wrapper, they are able to read/write to the `FitParams` and be</span>
<span class="sd">    aware of other callbacks that are running.</span>

<span class="sd">    Accounting for the interjection calls (`on_*_begin` &amp; `on_*_end`), the full optimisation loop is:</span>

<span class="sd">    1. Associate callbacks with wrapper (`set_wrapper`)</span>
<span class="sd">    2. `on_train_begin`</span>
<span class="sd">    3. for epoch in `n_epochs`:</span>
<span class="sd">        A. `state` = &quot;train&quot;</span>
<span class="sd">        B. `on_epoch_begin`</span>
<span class="sd">        C. for `p`, `passive` in enumerate(`trn_passives`):</span>
<span class="sd">            a. if `p` % `passive_bs` == 0:</span>
<span class="sd">                i. `on_volume_batch_begin`</span>
<span class="sd">                ii. `loss` = 0</span>
<span class="sd">            b. load `passive` into passive volume</span>
<span class="sd">            c. `on_volume_begin`</span>
<span class="sd">            d. for muon_batch in range(`n_mu_per_volume`//`mu_bs`):</span>
<span class="sd">                i. `on_mu_batch_begin`</span>
<span class="sd">                ii. Irradiate volume with `mu_bs` muons</span>
<span class="sd">                iii. Infer scatter locations</span>
<span class="sd">                iv. `on_scatter_end`</span>
<span class="sd">                v. Infer x0 and append to list of x0 predictions</span>
<span class="sd">                vi. `on_mu_batch_end`</span>
<span class="sd">            e. `on_x0_pred_begin`</span>
<span class="sd">            f. Compute overall x0 prediction</span>
<span class="sd">            g. `on_x0_pred_end`</span>
<span class="sd">            h. Compute loss based on precision and cost, and add to `loss`</span>
<span class="sd">            i. if `p`+1 % `passive_bs` == 0:</span>
<span class="sd">                i. `loss` = `loss`/`passive_bs`</span>
<span class="sd">                ii. `on_volume_batch_end`</span>
<span class="sd">                iii. Zero parameter gradients</span>
<span class="sd">                iv. `on_backwards_begin`</span>
<span class="sd">                v. Backpropagate `loss` and compute parameter gradients</span>
<span class="sd">                vi. `on_backwards_end`</span>
<span class="sd">                vii. Update detector parameters</span>
<span class="sd">                viii. Ensure detector parameters are within physical boundaries (`AbsDetectorLayer.conform_detector`)</span>
<span class="sd">                viv. `loss` = 0</span>
<span class="sd">            j. if len(`trn_passives`)-(`p`+1) &lt; `passive_bs`:</span>
<span class="sd">                i. Break</span>
<span class="sd">        D. `on_epoch_end`</span>
<span class="sd">        E. `state` = &quot;valid&quot;</span>
<span class="sd">        F. `on_epoch_begin`</span>
<span class="sd">        G. for `p`, `passive` in enumerate(`val_passives`):</span>
<span class="sd">            a. if `p` % `passive_bs` == 0:</span>
<span class="sd">                i. `on_volume_batch_begin`</span>
<span class="sd">                ii. `loss` = 0</span>
<span class="sd">            b. `on_volume_begin`</span>
<span class="sd">            c. for muon_batch in range(`n_mu_per_volume`//`mu_bs`):</span>
<span class="sd">                i. `on_mu_batch_begin`</span>
<span class="sd">                ii. Irradiate volume with `mu_bs` muons</span>
<span class="sd">                iii. Infer scatter locations</span>
<span class="sd">                iv. `on_scatter_end`</span>
<span class="sd">                v. Infer x0 and append to list of x0 predictions</span>
<span class="sd">                vi. `on_mu_batch_end`</span>
<span class="sd">            d. `on_x0_pred_begin`</span>
<span class="sd">            e. Compute overall x0 prediction</span>
<span class="sd">            f. `on_x0_pred_end`</span>
<span class="sd">            g. Compute loss based on precision and cost, and add to `loss`</span>
<span class="sd">            h. if `p`+1 % `passive_bs` == 0:</span>
<span class="sd">                i. `loss` = `loss`/`passive_bs`</span>
<span class="sd">                ii. `on_volume_batch_end`</span>
<span class="sd">            i. if len(`val_passives`)-(`p`+1) &lt; `passive_bs`:</span>
<span class="sd">                i. Break</span>
<span class="sd">        H. `on_epoch_end`</span>
<span class="sd">    4. `on_train_end`</span>

<span class="sd">    Arguments:</span>
<span class="sd">        volume: the volume containing the detectors to be optimised</span>
<span class="sd">        mu_opt: uninitialised optimiser to be used for adjusting the xy position of Gaussians</span>
<span class="sd">        norm_opt: uninitialised optimiser to be used for adjusting the normalisation of Gaussians</span>
<span class="sd">        sig_opt: uninitialised optimiser to be used for adjusting the scale of Gaussians</span>
<span class="sd">        z_pos_opt: uninitialised optimiser to be used for adjusting the z position of panels</span>
<span class="sd">        loss_func: optional loss function (required if planning to optimise the detectors)</span>
<span class="sd">        partial_scatter_inferrer: uninitialised class to be used for inferring muon scatter variables and trajectories</span>
<span class="sd">        partial_volume_inferrer:  uninitialised class to be used for inferring volume targets</span>
<span class="sd">        mu_generator: Optional generator class for muons. If None, will use :meth:`~tomopt.muon.generation. MuonGenerator2016.from_volume`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">volume</span><span class="p">:</span> <span class="n">Volume</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">mu_opt</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">,</span>
        <span class="n">norm_opt</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">,</span>
        <span class="n">sig_opt</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">,</span>
        <span class="n">z_pos_opt</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">,</span>
        <span class="n">loss_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbsDetectorLoss</span><span class="p">],</span>
        <span class="n">partial_scatter_inferrer</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">ScatterBatch</span><span class="p">]</span> <span class="o">=</span> <span class="n">ScatterBatch</span><span class="p">,</span>
        <span class="n">partial_volume_inferrer</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">AbsVolumeInferrer</span><span class="p">]</span> <span class="o">=</span> <span class="n">PanelX0Inferrer</span><span class="p">,</span>
        <span class="n">mu_generator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbsMuonGenerator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span>
            <span class="n">partial_opts</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;mu_opt&quot;</span><span class="p">:</span> <span class="n">mu_opt</span><span class="p">,</span> <span class="s2">&quot;norm_opt&quot;</span><span class="p">:</span> <span class="n">norm_opt</span><span class="p">,</span> <span class="s2">&quot;sig_opt&quot;</span><span class="p">:</span> <span class="n">sig_opt</span><span class="p">,</span> <span class="s2">&quot;z_pos_opt&quot;</span><span class="p">:</span> <span class="n">z_pos_opt</span><span class="p">},</span>
            <span class="n">loss_func</span><span class="o">=</span><span class="n">loss_func</span><span class="p">,</span>
            <span class="n">mu_generator</span><span class="o">=</span><span class="n">mu_generator</span><span class="p">,</span>
            <span class="n">partial_scatter_inferrer</span><span class="o">=</span><span class="n">partial_scatter_inferrer</span><span class="p">,</span>
            <span class="n">partial_volume_inferrer</span><span class="o">=</span><span class="n">partial_volume_inferrer</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="HeatMapVolumeWrapper.from_save"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.HeatMapVolumeWrapper.from_save">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_save</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">volume</span><span class="p">:</span> <span class="n">Volume</span><span class="p">,</span>
        <span class="n">mu_opt</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">,</span>
        <span class="n">norm_opt</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">,</span>
        <span class="n">sig_opt</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">,</span>
        <span class="n">z_pos_opt</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">,</span>
        <span class="n">loss_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbsDetectorLoss</span><span class="p">],</span>
        <span class="n">partial_scatter_inferrer</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">ScatterBatch</span><span class="p">]</span> <span class="o">=</span> <span class="n">ScatterBatch</span><span class="p">,</span>
        <span class="n">partial_volume_inferrer</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">AbsVolumeInferrer</span><span class="p">]</span> <span class="o">=</span> <span class="n">PanelX0Inferrer</span><span class="p">,</span>
        <span class="n">mu_generator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbsMuonGenerator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbsVolumeWrapper</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiates a new `HeatMapVolumeWrapper` and loads saved detector and optimiser parameters</span>

<span class="sd">        Arguments:</span>
<span class="sd">            name: file name with saved detector and optimiser parameters</span>
<span class="sd">            volume: the volume containing the detectors to be optimised</span>
<span class="sd">            mu_opt: uninitialised optimiser to be used for adjusting the xy position of Gaussians</span>
<span class="sd">            norm_opt: uninitialised optimiser to be used for adjusting the normalisation of Gaussians</span>
<span class="sd">            sig_opt: uninitialised optimiser to be used for adjusting the scale of Gaussians</span>
<span class="sd">            z_pos_opt: uninitialised optimiser to be used for adjusting the z position of panels</span>
<span class="sd">            loss_func: optional loss function (required if planning to optimise the detectors)</span>
<span class="sd">            partial_scatter_inferrer: uninitialised class to be used for inferring muon scatter variables and trajectories</span>
<span class="sd">            partial_volume_inferrer:  uninitialised class to be used for inferring volume targets</span>
<span class="sd">            mu_generator: Optional generator class for muons. If None, will use :meth:`~tomopt.muon.generation. MuonGenerator2016.from_volume`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">vw</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span>
            <span class="n">mu_opt</span><span class="o">=</span><span class="n">mu_opt</span><span class="p">,</span>
            <span class="n">norm_opt</span><span class="o">=</span><span class="n">norm_opt</span><span class="p">,</span>
            <span class="n">sig_opt</span><span class="o">=</span><span class="n">sig_opt</span><span class="p">,</span>
            <span class="n">z_pos_opt</span><span class="o">=</span><span class="n">z_pos_opt</span><span class="p">,</span>
            <span class="n">loss_func</span><span class="o">=</span><span class="n">loss_func</span><span class="p">,</span>
            <span class="n">mu_generator</span><span class="o">=</span><span class="n">mu_generator</span><span class="p">,</span>
            <span class="n">partial_scatter_inferrer</span><span class="o">=</span><span class="n">partial_scatter_inferrer</span><span class="p">,</span>
            <span class="n">partial_volume_inferrer</span><span class="o">=</span><span class="n">partial_volume_inferrer</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">vw</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vw</span></div>

    <span class="k">def</span> <span class="nf">_build_opt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialises the optimisers by associating them to the detector parameters.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            kwargs: uninitialised optimisers passed as keyword arguments</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">all_dets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="o">.</span><span class="n">get_detectors</span><span class="p">()</span>
        <span class="n">dets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">PanelDetectorLayer</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">all_dets</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">PanelDetectorLayer</span><span class="p">):</span>
                <span class="n">dets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opts</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;mu_opt&quot;</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;mu_opt&quot;</span><span class="p">]((</span><span class="n">p</span><span class="o">.</span><span class="n">mu</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">dets</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">panels</span><span class="p">)),</span>
            <span class="s2">&quot;norm_opt&quot;</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;norm_opt&quot;</span><span class="p">]((</span><span class="n">p</span><span class="o">.</span><span class="n">norm</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">dets</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">panels</span><span class="p">)),</span>
            <span class="s2">&quot;sig_opt&quot;</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;sig_opt&quot;</span><span class="p">]((</span><span class="n">p</span><span class="o">.</span><span class="n">sig</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">dets</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">panels</span><span class="p">)),</span>
            <span class="s2">&quot;z_pos_opt&quot;</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;z_pos_opt&quot;</span><span class="p">]((</span><span class="n">p</span><span class="o">.</span><span class="n">z</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">dets</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">l</span><span class="o">.</span><span class="n">panels</span><span class="p">)),</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="ArbVolumeWrapper"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.ArbVolumeWrapper">[docs]</a><span class="k">class</span> <span class="nc">ArbVolumeWrapper</span><span class="p">(</span><span class="n">AbsVolumeWrapper</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Arbitrary volume wrapper in which the user supplies pre-instantiated optimisers for whatever paramters should be optimised.</span>

<span class="sd">    Wrappers also provide for various quality-of-life methods, such as saving and loading detector configurations,</span>
<span class="sd">    and computing predictions with a fixed detector (:meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper.predict`)</span>

<span class="sd">    Fitting of a detector proceeds as training and validation epochs, each of which contains multiple batches of passive volumes.</span>
<span class="sd">    For each volume in a batch, the loss is evaluated using multiple batches of muons.</span>
<span class="sd">    The whole loop is:</span>

<span class="sd">    1. for epoch in `n_epochs`:</span>
<span class="sd">        A. `loss` = 0</span>
<span class="sd">        B. for `p`, `passive` in enumerate(`trn_passives`):</span>
<span class="sd">            a. load `passive` into passive volume</span>
<span class="sd">            b. for muon_batch in range(`n_mu_per_volume`//`mu_bs`):</span>
<span class="sd">                i. Irradiate volume with `mu_bs` muons</span>
<span class="sd">                ii. Infer passive volume</span>
<span class="sd">            c. Compute loss based on precision and cost, and add to `loss`</span>
<span class="sd">            d. if `p`+1 % `passive_bs` == 0:</span>
<span class="sd">                i. `loss` = `loss`/`passive_bs`</span>
<span class="sd">                ii. Backpropagate `loss` and update detector parameters</span>
<span class="sd">                iii. `loss` = 0</span>
<span class="sd">            e. if len(`trn_passives`)-(`p`+1) &lt; `passive_bs`:</span>
<span class="sd">                i. Break</span>

<span class="sd">        C. `val_loss` = 0</span>
<span class="sd">        D. for `p`, `passive` in enumerate(`val_passives`):</span>
<span class="sd">            a. load `passive` into passive volume</span>
<span class="sd">            b. for muon_batch in range(`n_mu_per_volume`//`mu_bs`):</span>
<span class="sd">                i. Irradiate volume with `mu_bs` muons</span>
<span class="sd">                ii. Infer passive volume</span>
<span class="sd">                iii. Compute loss based on precision and cost, and add to `val_loss`</span>
<span class="sd">            c. if len(`val_passives`)-(`p`+1) &lt; `passive_bs`:</span>
<span class="sd">                i. Break</span>
<span class="sd">        E. `val_loss` = `val_loss`/`p`</span>

<span class="sd">    In implementation, the loop is broken up into several functions:</span>
<span class="sd">        :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper._fit_epoch` runs one full epoch of volumes</span>
<span class="sd">            and updates for both training and validation</span>
<span class="sd">        :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper._scan_volumes` runs over all training/validation volumes,</span>
<span class="sd">            updating parameters when necessary</span>
<span class="sd">        :meth:`~tomopt.optimisation.wrapper.volume_wrapper.AbsVolumeWrapper._scan_volume` irradiates a single volume with muons multiple batches,</span>
<span class="sd">            and computes the loss for that volume</span>

<span class="sd">    The optimisation and prediction loops are supported by a stateful callback mechanism.</span>
<span class="sd">    The base callback is :class:`~tomopt.optimisation.callbacks.callback.Callback`, which can interject at various points in the loops.</span>
<span class="sd">    All aspects of the optimisation and prediction are stored in a :class:`~tomopt.optimisation.wrapper.volume_wrapper.FitParams` data class,</span>
<span class="sd">    since the callbacks are also stored there, and the callbacks have a reference to the wrapper, they are able to read/write to the `FitParams` and be</span>
<span class="sd">    aware of other callbacks that are running.</span>

<span class="sd">    Accounting for the interjection calls (`on_*_begin` &amp; `on_*_end`), the full optimisation loop is:</span>

<span class="sd">    1. Associate callbacks with wrapper (`set_wrapper`)</span>
<span class="sd">    2. `on_train_begin`</span>
<span class="sd">    3. for epoch in `n_epochs`:</span>
<span class="sd">        A. `state` = &quot;train&quot;</span>
<span class="sd">        B. `on_epoch_begin`</span>
<span class="sd">        C. for `p`, `passive` in enumerate(`trn_passives`):</span>
<span class="sd">            a. if `p` % `passive_bs` == 0:</span>
<span class="sd">                i. `on_volume_batch_begin`</span>
<span class="sd">                ii. `loss` = 0</span>
<span class="sd">            b. load `passive` into passive volume</span>
<span class="sd">            c. `on_volume_begin`</span>
<span class="sd">            d. for muon_batch in range(`n_mu_per_volume`//`mu_bs`):</span>
<span class="sd">                i. `on_mu_batch_begin`</span>
<span class="sd">                ii. Irradiate volume with `mu_bs` muons</span>
<span class="sd">                iii. Infer scatter locations</span>
<span class="sd">                iv. `on_scatter_end`</span>
<span class="sd">                v. Infer x0 and append to list of x0 predictions</span>
<span class="sd">                vi. `on_mu_batch_end`</span>
<span class="sd">            e. `on_x0_pred_begin`</span>
<span class="sd">            f. Compute overall x0 prediction</span>
<span class="sd">            g. `on_x0_pred_end`</span>
<span class="sd">            h. Compute loss based on precision and cost, and add to `loss`</span>
<span class="sd">            i. if `p`+1 % `passive_bs` == 0:</span>
<span class="sd">                i. `loss` = `loss`/`passive_bs`</span>
<span class="sd">                ii. `on_volume_batch_end`</span>
<span class="sd">                iii. Zero parameter gradients</span>
<span class="sd">                iv. `on_backwards_begin`</span>
<span class="sd">                v. Backpropagate `loss` and compute parameter gradients</span>
<span class="sd">                vi. `on_backwards_end`</span>
<span class="sd">                vii. Update detector parameters</span>
<span class="sd">                viii. Ensure detector parameters are within physical boundaries (`AbsDetectorLayer.conform_detector`)</span>
<span class="sd">                viv. `loss` = 0</span>
<span class="sd">            j. if len(`trn_passives`)-(`p`+1) &lt; `passive_bs`:</span>
<span class="sd">                i. Break</span>
<span class="sd">        D. `on_epoch_end`</span>
<span class="sd">        E. `state` = &quot;valid&quot;</span>
<span class="sd">        F. `on_epoch_begin`</span>
<span class="sd">        G. for `p`, `passive` in enumerate(`val_passives`):</span>
<span class="sd">            a. if `p` % `passive_bs` == 0:</span>
<span class="sd">                i. `on_volume_batch_begin`</span>
<span class="sd">                ii. `loss` = 0</span>
<span class="sd">            b. `on_volume_begin`</span>
<span class="sd">            c. for muon_batch in range(`n_mu_per_volume`//`mu_bs`):</span>
<span class="sd">                i. `on_mu_batch_begin`</span>
<span class="sd">                ii. Irradiate volume with `mu_bs` muons</span>
<span class="sd">                iii. Infer scatter locations</span>
<span class="sd">                iv. `on_scatter_end`</span>
<span class="sd">                v. Infer x0 and append to list of x0 predictions</span>
<span class="sd">                vi. `on_mu_batch_end`</span>
<span class="sd">            d. `on_x0_pred_begin`</span>
<span class="sd">            e. Compute overall x0 prediction</span>
<span class="sd">            f. `on_x0_pred_end`</span>
<span class="sd">            g. Compute loss based on precision and cost, and add to `loss`</span>
<span class="sd">            h. if `p`+1 % `passive_bs` == 0:</span>
<span class="sd">                i. `loss` = `loss`/`passive_bs`</span>
<span class="sd">                ii. `on_volume_batch_end`</span>
<span class="sd">            i. if len(`val_passives`)-(`p`+1) &lt; `passive_bs`:</span>
<span class="sd">                i. Break</span>
<span class="sd">        H. `on_epoch_end`</span>
<span class="sd">    4. `on_train_end`</span>

<span class="sd">    Arguments:</span>
<span class="sd">        volume: the volume containing the detectors to be optimised</span>
<span class="sd">        opts: Dict of strings mapping to initialised optimisers</span>
<span class="sd">        loss_func: optional loss function (required if planning to optimise the detectors)</span>
<span class="sd">        partial_scatter_inferrer: uninitialised class to be used for inferring muon scatter variables and trajectories</span>
<span class="sd">        partial_volume_inferrer:  uninitialised class to be used for inferring volume targets</span>
<span class="sd">        mu_generator: Optional generator class for muons. If None, will use :meth:`~tomopt.muon.generation. MuonGenerator2016.from_volume`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">volume</span><span class="p">:</span> <span class="n">Volume</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">opts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">],</span>
        <span class="n">loss_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbsDetectorLoss</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">partial_scatter_inferrer</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">ScatterBatch</span><span class="p">]</span> <span class="o">=</span> <span class="n">ScatterBatch</span><span class="p">,</span>
        <span class="n">partial_volume_inferrer</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">AbsVolumeInferrer</span><span class="p">]</span> <span class="o">=</span> <span class="n">PanelX0Inferrer</span><span class="p">,</span>
        <span class="n">mu_generator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbsMuonGenerator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span>
            <span class="n">partial_opts</span><span class="o">=</span><span class="p">{},</span>
            <span class="n">loss_func</span><span class="o">=</span><span class="n">loss_func</span><span class="p">,</span>
            <span class="n">mu_generator</span><span class="o">=</span><span class="n">mu_generator</span><span class="p">,</span>
            <span class="n">partial_scatter_inferrer</span><span class="o">=</span><span class="n">partial_scatter_inferrer</span><span class="p">,</span>
            <span class="n">partial_volume_inferrer</span><span class="o">=</span><span class="n">partial_volume_inferrer</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opts</span> <span class="o">=</span> <span class="n">opts</span>

<div class="viewcode-block" id="ArbVolumeWrapper.from_save"><a class="viewcode-back" href="../../../../tomopt.optimisation.wrapper.html#tomopt.optimisation.wrapper.volume_wrapper.ArbVolumeWrapper.from_save">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_save</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">volume</span><span class="p">:</span> <span class="n">Volume</span><span class="p">,</span>
        <span class="n">opts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optimizer</span><span class="p">],</span>
        <span class="n">loss_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbsDetectorLoss</span><span class="p">],</span>
        <span class="n">partial_scatter_inferrer</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">ScatterBatch</span><span class="p">]</span> <span class="o">=</span> <span class="n">ScatterBatch</span><span class="p">,</span>
        <span class="n">partial_volume_inferrer</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">AbsVolumeInferrer</span><span class="p">]</span> <span class="o">=</span> <span class="n">PanelX0Inferrer</span><span class="p">,</span>
        <span class="n">mu_generator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AbsMuonGenerator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbsVolumeWrapper</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiates a new `PanelVolumeWrapper` and loads saved detector and optimiser parameters</span>

<span class="sd">        Arguments:</span>
<span class="sd">            name: file name with saved detector and optimiser parameters</span>
<span class="sd">            volume: the volume containing the detectors to be optimised</span>
<span class="sd">            opts: Dict of strings mapping to initialised optimisers</span>
<span class="sd">            loss_func: optional loss function (required if planning to optimise the detectors)</span>
<span class="sd">            partial_scatter_inferrer: uninitialised class to be used for inferring muon scatter variables and trajectories</span>
<span class="sd">            partial_volume_inferrer:  uninitialised class to be used for inferring volume targets</span>
<span class="sd">            mu_generator: Optional generator class for muons. If None, will use :meth:`~tomopt.muon.generation. MuonGenerator2016.from_volume`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">vw</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">volume</span><span class="o">=</span><span class="n">volume</span><span class="p">,</span>
            <span class="n">opts</span><span class="o">=</span><span class="n">opts</span><span class="p">,</span>
            <span class="n">loss_func</span><span class="o">=</span><span class="n">loss_func</span><span class="p">,</span>
            <span class="n">partial_scatter_inferrer</span><span class="o">=</span><span class="n">partial_scatter_inferrer</span><span class="p">,</span>
            <span class="n">partial_volume_inferrer</span><span class="o">=</span><span class="n">partial_volume_inferrer</span><span class="p">,</span>
            <span class="n">mu_generator</span><span class="o">=</span><span class="n">mu_generator</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">vw</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vw</span></div>

    <span class="k">def</span> <span class="nf">_build_opt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">PartialOpt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span></div>
</pre></div>

             </article>
             
            </div>
            <footer>
  

  <hr>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021-2024, TomOpt Authors.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/GilesStrong/tomopt_sphinx_theme">theme</a> based on a <a href="https://github.com/pytorch/pytorch_sphinx_theme">theme</a> provided by <a href="https://pytorch.org/">PyTorch</a> based on a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>
     

</footer>

          </div>
        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              
            </div>
          </div>
        </div>
      </section>
    </div>

  


  

     
       <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
         <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
         <script src="../../../../_static/doctools.js"></script>
         <script src="../../../../_static/sphinx_highlight.js"></script>
     

  

  <script type="text/javascript" src="../../../../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../../../../_static/js/vendor/bootstrap.min.js"></script>
  <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

  <!-- Begin Footer -->

  <div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
    <div class="container">
      <div class="row">
        <div class="col-md-6 text-center">
          <h2>Docs</h2>
          <p>Access comprehensive developer and user documentation for TomOpt</p>
          <a class="with-right-arrow" href="https://tomopt.readthedocs.io/en/stable">View Docs</a>
        </div>

        <div class="col-md-6 text-center">
          <h2>Tutorials</h2>
          <p>Get tutorials for beginner and advanced researchers demonstrating many of the features of TomOpt</p>
          <a class="with-right-arrow" href="https://github.com/GilesStrong/mode_muon_tomography#examples">View Tutorials</a>
        </div>

        <!-- <div class="col-md-4 text-center">
          <h2>Resources</h2>
          <p>Find development resources and get your questions answered</p>
          <a class="with-right-arrow" href="">View Resources</a>
        </div> -->
      </div>
    </div>
  </div>

  <footer class="site-footer">
    <div class="container footer-container">
      <div class="footer-logo-wrapper">
        <a href="https://tomopt.readthedocs.io/en/stable" class="footer-logo"></a>
      </div>

      <div class="footer-links-wrapper">
        <div class="footer-links-col">
          <ul>
            <!-- <li class="list-title"><a href="https://tomopt.readthedocs.io/en/stable">TomOpt</a></li> -->
            <!-- <li><a href="">Get Started</a></li> -->
            <!-- <li><a href="">Features</a></li> -->
            <!-- <li><a href="">Ecosystem</a></li> -->
            <!-- <li><a href="">Blog</a></li> -->
            <!-- <li><a href="">Resources</a></li> -->
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="">Support</a></li>
            <li><a href="https://github.com/GilesStrong/mode_muon_tomography#examples">Tutorials</a></li>
            <li><a href="https://tomopt.readthedocs.io/en/stable">Docs</a></li>
            <!-- <li><a href="" target="_blank">Discuss</a></li> -->
            <li><a href="https://github.com/GilesStrong/mode_muon_tomography/blob/main/CHANGES.md" target="_blank">Change Log</a></li>
            <li><a href="https://github.com/GilesStrong/mode_muon_tomography/issues" target="_blank">Github Issues</a></li>
            <li><a href="https://github.com/GilesStrong/mode_muon_tomography/blob/main/CITATION.md" target="_blank">Citation</a></li>
            <!-- <li><a href="" target="_blank">Slack</a></li> -->
            <!-- <li><a href="https://github.com/GilesStrong/mode_muon_tomography/blob/main/CONTRIBUTING.md" target="_blank">Contributing</a></li> -->
          </ul>
        </div>

        <!-- <div class="footer-links-col follow-us-col">
          <ul>
            <li class="list-title">Follow Us</li>
            <li>
              <div id="mc_embed_signup">
                <form
                  action="https://twitter.us14.list-manage.com/subscribe/post?u=75419c71fe0a935e53dfa4a3f&id=91d0dccd39"
                  method="post"
                  id="mc-embedded-subscribe-form"
                  name="mc-embedded-subscribe-form"
                  class="email-subscribe-form validate"
                  target="_blank"
                  novalidate>
                  <div id="mc_embed_signup_scroll" class="email-subscribe-form-fields-wrapper">
                    <div class="mc-field-group">
                      <label for="mce-EMAIL" style="display:none;">Email Address</label>
                      <input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" placeholder="Email Address">
                    </div>

                    <div id="mce-responses" class="clear">
                      <div class="response" id="mce-error-response" style="display:none"></div>
                      <div class="response" id="mce-success-response" style="display:none"></div>
                    </div>    real people should not fill this in and expect good things - do not remove this or risk form bot signups

                    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_75419c71fe0a935e53dfa4a3f_91d0dccd39" tabindex="-1" value=""></div>

                    <div class="clear">
                      <input type="submit" value="" name="subscribe" id="mc-embedded-subscribe" class="button email-subscribe-button">
                    </div>
                  </div>
                </form>
              </div>

            </li>
          </ul>

          <div class="footer-social-icons">
            <a href="" target="_blank" class="facebook"></a>
            <a href="" target="_blank" class="twitter"></a>
          </div>
        </div> -->
      </div>
    </div>
  </footer>

  <!-- <div class="cookie-banner-wrapper">
  <div class="container">
    <p class="gdpr-notice">To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebooks Cookies Policy applies. Learn more, including about available controls: <a href="https://www.facebook.com/policies/cookies/">Cookies Policy</a>.</p>
    <img class="close-button" src="../../../../_static/images/pytorch-x.svg">
  </div>
</div> -->

  <!-- End Footer -->

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://tomopt.readthedocs.io/en/stable" aria-label="TomOpt"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <!-- <li>
            <a href="#">Get Started</a>
          </li> -->

          <!-- <li>
            <a href="#">Features</a>
          </li> -->

          <!-- <li>
            <a href="#">Ecosystem</a>
          </li> -->

          <!-- <li>
            <a href="">Blog</a>
          </li> -->

          <li>
            <a href="https://github.com/GilesStrong/mode_muon_tomography#examples">Tutorials</a>
          </li>

          <li>
            <a href="https://tomopt.readthedocs.io/en/stable">Docs</a>
          </li>

          <!-- <li>
            <a href="">Resources</a>
          </li> -->

          <li>
            <a href="https://github.com/GilesStrong/mode_muon_tomography">Github</a>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../../../../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>